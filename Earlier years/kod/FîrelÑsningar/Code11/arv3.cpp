/***************************************************************************
* TNG033, Fö 11                                                            *
* Defines a hierarchy of Employees: see Fö10                               *
* An operator<< is defined                                                 *
* function display() is now virtual --> dynamic binding is used            *
* Employee destructor must also be virtual                                 *
* **************************************************************************/

#include <iostream>
#include <iomanip>
#include <string>
#include <new>

using namespace std;



/**************************
* Employee class          *
***************************/

class Employee
{
  public:

    //constructor
    Employee(string s = "") : name(s) {    };

    //Destructor
    virtual ~Employee() { };

    void change_name(const string s) { name = s; };

    friend ostream& operator<<(ostream& os, const Employee& E);


	protected:
        string name;

        virtual void display(ostream& os) const
        {
            os << "Name: " << name << endl;
        } ;
};

//Friend functions are not NOT member function of class Employee
ostream& operator<<(ostream& os, const Employee& E)
{
    E.display(os); //dynamic binding: call function display(os) for the class of the object referred by E

    return os;
}



/**************************
* Teacher class           *
***************************/


class Teacher : public Employee {
  public:

    //constructor
    Teacher(string s = "", string *c = nullptr, int n = 0);

    //copy constructor
    Teacher(const Teacher &T);

    ~Teacher() //destructor
    {
        //cout << "Teachers destructor ..." << endl;
        delete [] courses;
    }

    const Teacher& operator=(const Teacher &T);

    bool gives_course(string code) const;


	protected:
        string *courses;  //array of courses codes given by the teacher
        int n_courses;    //number of courses given by the teacher

        void display(ostream& os) const;
};


/////////////////////////////////////////
//Teacher's member functions definitions
/////////////////////////////////////////


//constructor
Teacher::Teacher(string s, string *c, int n)
  : n_courses(n), Employee(s) //call constructor of base class to initialize name
{
    courses = new string[n_courses]; //allocate memory for the course codes

    for(int i = 0; i < n_courses; i++) //copy course codes from array c
        courses[i] = c[i];
};


//copy constructor
Teacher::Teacher(const Teacher &T)
 : n_courses(T.n_courses), Employee(T) //call base class copy constructor
{
    courses = new string[n_courses]; //allocate memory for the course codes

    for(int i = 0; i < n_courses; i++)
        courses[i] = T.courses[i];  //copy course codes from array c
};


const Teacher& Teacher::operator=(const Teacher &T)
{
    if (this != &T) //test self-assignment
    {
        name = T.name;

        //1. Delete old memory
        delete [] courses;

        //2. Allocate new memory
        courses = new string[T.n_courses];

        //3. Copy
        n_courses = T.n_courses;
        for(int i = 0; i < n_courses; i++)
            courses[i] = T.courses[i];
    }

    return *this;
}



bool Teacher::gives_course(string code) const
{
    for(int i = 0; i < n_courses; i++)
        if (code == courses[i])
            return true;

    return false;
}


void Teacher::display(ostream& os) const
{
    os << "Teacher: " << name << endl;

    os << "Courses: ";
    for(int i = 0; i < n_courses-1; i++)
            cout << courses[i] << ", ";

    os << courses[n_courses-1] << endl;
}



/**************************
* Programmer class        *
***************************/

class Programmer : public Teacher
{
  public:

    //constructor
    Programmer(string s = "", string *c = NULL, int n = 0, string f = "C++")
     : Teacher(s, c, n) //call constructor of Teacher class
    {
        fav_lang = f;
    };

      //Generated by the compiler
//    Programmer(const Programmer &p)
//    {
//        Teacher::operator=(p);
//        fav_lang =p.fav_lang;
//    }

	protected:
        string fav_lang;  //favourite programming language

        void display(ostream& os) const;
};


void Programmer::display(ostream& os) const
{
    os << "Programmer: " << name << endl;
    os << "Favourite prog. language: " << fav_lang << endl;

    os << "Courses: ";
    for(int i = 0; i < n_courses-1; i++)
        os << courses[i] << ", ";

    os << courses[n_courses-1] << endl;
};



/**************************
* Researcher class        *
***************************/

class Researcher : public Employee
{
  public:

    //constructor
    Researcher(string s = "", string a = "")
     : Employee(s) //call constructor of base class
    {
        area = a;
    };


	protected:
        string area;  //area of research

        void display(ostream& os) const
        {
            os << "Researcher: " << name << endl;
            os << "Area of research: " << area << endl;
        };
};



/*************************************************
* main()  -- testing                             *
**************************************************/


int main()
{
    const int MAX = 100;

    string C1[] = {"TND012", "TNG033", "TNK031"};
    string C2[] = {"TNCG018", "TND004"};

    Teacher T("Anna", C2, 2);
    Programmer P("Aida", C1, 3, "Smalltalk");
    Researcher R("Monika", "Swearing theory");

    Employee* DB[MAX];
    int howMany = 3;

    DB[0] = &T;
    DB[1] = &P;
    DB[2] = &R;

    for(int i = 0; i < howMany; i++)
    {
        cout << *DB[i] << endl;
    }

    //Destructor for objects T, P, and R are called automatically

   return 0;
}


